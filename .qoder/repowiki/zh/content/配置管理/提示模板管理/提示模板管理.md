# 提示模板管理

<cite>
**本文档引用的文件**   
- [conf.py](file://rdagent/app/data_science/conf.py)
- [prompts.yaml](file://rdagent/components/coder/CoSTEER/prompts.yaml)
- [prompts.yaml](file://rdagent/app/finetune/llm/prompts.yaml)
- [prompts.py](file://rdagent/core/prompts.py)
- [prompts.yaml](file://rdagent/utils/prompts.yaml)
- [prompts_v2.yaml](file://rdagent/scenarios/data_science/proposal/exp_gen/prompts_v2.yaml)
- [prompts.yaml](file://rdagent/components/coder/data_science/pipeline/prompts.yaml)
- [tpl.py](file://rdagent/utils/agent/tpl.py)
- [share.yaml](file://rdagent/scenarios/data_science/share.yaml)
- [prompts.yaml](file://rdagent/scenarios/data_science/scen/prompts.yaml)
- [prompts.yaml](file://rdagent/components/agent/context7/prompts.yaml)
</cite>

## 目录
1. [介绍](#介绍)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构概述](#架构概述)
5. [详细组件分析](#详细组件分析)
6. [依赖分析](#依赖分析)
7. [性能考虑](#性能考虑)
8. [故障排除指南](#故障排除指南)
9. [结论](#结论)
10. [附录](#附录)（如有必要）

## 介绍
本文档全面解析提示模板的组织结构与管理机制。我们将深入探讨YAML格式提示模板的目录布局，展示不同组件（如CoSTEER、data_science）如何组织其专属提示文件。文档将详细解释模板变量注入机制和条件逻辑使用方法，提供多层级模板继承与覆盖的示例，说明如何在场景特定配置中定制通用提示。此外，我们将分析提示工程的最佳实践，包括系统角色设置(system_prompt_role)、思维链提示(think标签处理)和响应模式控制(enable_response_schema)，并包含模板调试技巧和版本管理建议。

## 项目结构
提示模板系统采用分层的目录结构，将通用模板与特定场景模板分离，实现代码复用和灵活定制。系统通过YAML文件存储提示模板，并利用Jinja2模板引擎实现动态内容注入和条件逻辑处理。

```mermaid
graph TD
Templates[提示模板系统]
--> General[通用模板]
--> Specific[特定场景模板]
General --> CoSTEER[CoSTEER组件]
General --> DataScience[data_science组件]
General --> Utils[工具组件]
Specific --> Finetune[微调场景]
Specific --> Kaggle[Kaggle竞赛]
Specific --> Qlib[量化金融]
CoSTEER --> prompts_yaml[prompts.yaml]
DataScience --> pipeline[pipeline/prompts.yaml]
DataScience --> share[share.yaml]
Utils --> agent[agent/tpl.py]
Utils --> prompts[prompts.yaml]
Finetune --> llm[llm/tpl/scenarios/data_science/proposal/exp_gen/prompts_v2.yaml]
Kaggle --> proposal[proposal/exp_gen/prompts_v2.yaml]
Qlib --> proposal[proposal/prompts.yaml]
```

**Diagram sources**
- [prompts.yaml](file://rdagent/components/coder/CoSTEER/prompts.yaml)
- [prompts.yaml](file://rdagent/components/coder/data_science/pipeline/prompts.yaml)
- [share.yaml](file://rdagent/scenarios/data_science/share.yaml)
- [tpl.py](file://rdagent/utils/agent/tpl.py)
- [prompts_v2.yaml](file://rdagent/scenarios/data_science/proposal/exp_gen/prompts_v2.yaml)

**Section sources**
- [prompts.yaml](file://rdagent/components/coder/CoSTEER/prompts.yaml)
- [prompts.yaml](file://rdagent/components/coder/data_science/pipeline/prompts.yaml)
- [share.yaml](file://rdagent/scenarios/data_science/share.yaml)

## 核心组件
提示模板系统的核心组件包括模板加载器(T)、模板渲染引擎和配置管理系统。模板加载器负责从文件系统中加载YAML模板，支持相对路径和绝对路径引用，并实现了模板继承和覆盖机制。模板渲染引擎基于Jinja2，支持变量注入、条件逻辑和模板包含功能。配置管理系统通过Pydantic设置模型管理全局配置，允许通过环境变量覆盖默认设置。

**Section sources**
- [tpl.py](file://rdagent/utils/agent/tpl.py)
- [conf.py](file://rdagent/app/data_science/conf.py)
- [prompts.py](file://rdagent/core/prompts.py)

## 架构概述
提示模板系统采用分层架构，从底层的模板加载到上层的模板渲染，形成完整的提示管理解决方案。系统通过RDAT类封装模板操作，提供简洁的API接口。模板继承机制允许特定场景覆盖通用模板，实现灵活的配置管理。

```mermaid
classDiagram
class RDAT {
+uri : str
+template : str
-__init__(uri : str, ftype : str)
+r(**context : Any) str
}
class Prompts {
+__init__(file_path : Path)
+__getitem__(key : str) str
+__setitem__(key : str, value : str)
}
class T {
+__init__(uri : str, ftype : str)
+r(**context : Any) str
}
RDAT --> Prompts : "使用"
T --> RDAT : "实例化"
RDAT --> load_content : "调用"
load_content --> get_caller_dir : "调用"
```

**Diagram sources**
- [tpl.py](file://rdagent/utils/agent/tpl.py#L120-L147)
- [prompts.py](file://rdagent/core/prompts.py#L0-L20)

## 详细组件分析
### 模板加载与渲染机制
提示模板系统的核心是模板加载与渲染机制，它通过`tpl.py`文件中的`RDAT`类实现。该类提供了一个简洁的接口来加载和渲染模板，支持YAML和文本格式的模板文件。

#### 模板加载机制
模板加载器`load_content`函数实现了复杂的文件路径解析和加载优先级逻辑。它支持多种URI格式，包括相对路径和绝对路径引用，并考虑了应用模板覆盖的场景。

```mermaid
flowchart TD
Start([开始加载模板]) --> ParseURI["解析URI: path_part 和 yaml_trace"]
ParseURI --> CheckRelative{"路径是否以'.'开头?"}
CheckRelative --> |是| RelativePath["构建相对路径列表"]
CheckRelative --> |否| AbsolutePath["构建绝对路径列表"]
RelativePath --> AddAppTpl{"存在应用模板(app_tpl)?"}
AbsolutePath --> AddAppTpl
AddAppTpl --> |是| InsertAppPath["在路径列表开头插入应用模板路径"]
AddAppTpl --> |否| Continue["继续"]
InsertAppPath --> Continue
Continue --> TryLoad["遍历路径列表尝试加载"]
TryLoad --> FileExists{"文件存在?"}
FileExists --> |否| NextPath["尝试下一个路径"]
FileExists --> |是| IsYaml{"文件类型为YAML?"}
IsYaml --> |是| LoadYaml["加载YAML内容"]
IsYaml --> |否| LoadText["加载文本内容"]
LoadYaml --> TraverseYaml{"存在yaml_trace?"}
TraverseYaml --> |是| GetYamlValue["遍历YAML内容获取指定键值"]
TraverseYaml --> |否| ReturnContent["返回YAML根内容"]
GetYamlValue --> ReturnContent
LoadText --> ReturnContent
ReturnContent --> End([返回模板内容])
NextPath --> TryLoad
```

**Diagram sources**
- [tpl.py](file://rdagent/utils/agent/tpl.py#L41-L96)

#### 模板渲染机制
模板渲染通过`RDAT`类的`r`方法实现，该方法使用Jinja2的`Environment`和`FunctionLoader`来支持`{% include %}`语法，允许在一个模板中包含另一个模板的内容。

```mermaid
sequenceDiagram
participant User as "用户"
participant RDAT as "RDAT类"
participant Env as "Jinja2 Environment"
participant Loader as "FunctionLoader"
participant Content as "load_content函数"
User->>RDAT : 调用r(**context)
RDAT->>Env : 创建Environment实例
Env->>Loader : 使用FunctionLoader(load_content)
RDAT->>Env : from_string(self.template)
RDAT->>Env : render(**context)
Env->>Loader : 请求模板内容
Loader->>Content : 调用load_content(uri)
Content-->>Loader : 返回模板内容
Env-->>RDAT : 返回渲染后的字符串
RDAT->>RDAT : 清理多余换行
RDAT->>User : 返回最终渲染结果
```

**Diagram sources**
- [tpl.py](file://rdagent/utils/agent/tpl.py#L120-L147)

### 模板变量注入与条件逻辑
提示模板系统充分利用Jinja2模板引擎的强大功能，支持复杂的变量注入和条件逻辑处理，使得模板能够根据运行时上下文动态生成内容。

#### 变量注入机制
系统通过`r`方法的`**context`参数接收上下文变量，并将其注入到模板中。这些变量可以是简单的字符串，也可以是复杂的嵌套对象。

```mermaid
classDiagram
class TemplateContext {
+scenario_desc : str
+sota_exp_desc : str
+exp_and_feedback_list_desc : str
+problems : str
+hypotheses_formatted : str
+metric_name : str
+time_limit : str
+runtime_environment : str
+plan : object
+sibling_hypotheses : list
+enable_idea_pool : bool
+enable_simple_hypothesis : bool
+enable_scale_check : bool
}
class TemplateRenderer {
+render(template : str, context : TemplateContext) str
}
class PromptTemplate {
+system : str
+user : str
}
TemplateRenderer --> TemplateContext : "接收"
TemplateRenderer --> PromptTemplate : "渲染"
PromptTemplate --> TemplateContext : "引用变量"
```

**Diagram sources**
- [prompts_v2.yaml](file://rdagent/scenarios/data_science/proposal/exp_gen/prompts_v2.yaml#L0-L799)

#### 条件逻辑处理
模板中的条件逻辑通过Jinja2的`{% if %}`、`{% else %}`和`{% endif %}`语法实现，允许根据不同的配置选项或运行时状态生成不同的提示内容。

```mermaid
flowchart TD
A[开始渲染模板] --> B{"plan.draft为真?"}
B --> |是| C[使用场景优先焦点]
B --> |否| D[使用SOTA对齐分析]
C --> E{"存在sibling_hypotheses?"}
D --> F{"存在sibling_hypotheses?"}
E --> |是| G[添加多样性要求]
E --> |否| H[跳过多样性要求]
F --> |是| I[添加多样性要求]
F --> |否| J[跳过多样性要求]
G --> K[生成最终提示]
H --> K
I --> K
J --> K
K --> L[结束渲染]
```

**Diagram sources**
- [prompts_v2.yaml](file://rdagent/scenarios/data_science/proposal/exp_gen/prompts_v2.yaml#L0-L799)

### 多层级模板继承与覆盖
系统实现了多层级的模板继承与覆盖机制，允许特定场景的模板覆盖通用模板，同时保持代码的可维护性和可扩展性。

#### 模板继承示例
以数据科学场景的提示模板为例，系统通过`{% include %}`语法实现了模板继承，允许在特定模板中复用通用模板的内容。

```mermaid
graph TD
Base[基础模板]
--> Share[共享模板]
--> Specific[特定场景模板]
Share --> scen_role["scen.role"]
Share --> component_spec["component_spec.*"]
Share --> hyperparameter["spec.hyperparameter"]
Specific --> exp_gen["exp_gen/prompts_v2.yaml"]
Specific --> finetune["finetune/llm/tpl/scenarios/data_science/proposal/exp_gen/prompts_v2.yaml"]
exp_gen --> Include1["{% include 'scenarios.data_science.share:scen.role' %}"]
exp_gen --> Include2["{% include 'scenarios.data_science.share:spec.hyperparameter' %}"]
finetune --> Include3["{% include 'scenarios.data_science.share:scen.role' %}"]
finetune --> Include4["{% include 'scenarios.data_science.share:spec.hyperparameter' %}"]
Include1 --> scen_role
Include2 --> hyperparameter
Include3 --> scen_role
Include4 --> hyperparameter
```

**Diagram sources**
- [prompts_v2.yaml](file://rdagent/scenarios/data_science/proposal/exp_gen/prompts_v2.yaml#L0-L799)
- [prompts_v2.yaml](file://rdagent/app/finetune/llm/tpl/scenarios/data_science/proposal/exp_gen/prompts_v2.yaml#L0-L82)

### 提示工程最佳实践
#### 系统角色设置
系统通过`scen.role`模板定义了统一的系统角色，确保所有提示都以一致的身份和专业水平进行响应。

```mermaid
classDiagram
class SystemRole {
+role : str
+input_path : str
+cache_path : str
}
class DataScienceRole {
+role : "Kaggle Grandmaster and expert ML engineer"
+input_path : "./workspace_input/"
+cache_path : "./workspace_cache/"
}
class Context7Role {
+role : "helpful assistant"
+input_path : N/A
+cache_path : N/A
}
SystemRole <|-- DataScienceRole
SystemRole <|-- Context7Role
```

**Diagram sources**
- [share.yaml](file://rdagent/scenarios/data_science/share.yaml#L0-L380)
- [prompts.yaml](file://rdagent/components/agent/context7/prompts.yaml#L0-L59)

#### 思维链提示
系统通过分阶段的提示设计实现了思维链(Chain-of-Thought)提示，引导模型逐步完成复杂的分析任务。

```mermaid
sequenceDiagram
participant Model as "大语言模型"
participant System as "系统"
System->>Model : scenario_problem : 分析场景并识别关键挑战
Model-->>System : 返回关键挑战列表
System->>Model : feedback_problem : 基于历史反馈提取学习和未解决问题
Model-->>System : 返回学习和未解决问题
System->>Model : hypothesis_gen : 为每个挑战生成假设
Model-->>System : 返回假设列表
System->>Model : hypothesis_critique : 批评假设
Model-->>System : 返回批评意见
System->>Model : hypothesis_rewrite : 重写假设
Model-->>System : 返回重写后的假设
System->>Model : hypothesis_select : 选择最佳假设
Model-->>System : 返回选定的假设
System->>Model : task_gen : 生成任务设计
Model-->>System : 返回任务设计
```

**Diagram sources**
- [prompts_v2.yaml](file://rdagent/scenarios/data_science/proposal/exp_gen/prompts_v2.yaml#L0-L799)

#### 响应模式控制
系统通过`enable_response_schema`配置项控制是否启用结构化响应模式，确保模型输出符合预期的JSON格式。

```mermaid
flowchart TD
A[开始API调用] --> B{"supports_response_schema为真?"}
B --> |是| C[启用JSON模式]
B --> |否| D[使用文本模式]
C --> E[设置response_format为JSON]
D --> F[使用普通文本响应]
E --> G[发送请求到LLM]
F --> G
G --> H[接收响应]
H --> I{"响应为JSON格式?"}
I --> |是| J[解析JSON]
I --> |否| K[尝试手动解析]
J --> L[返回结构化数据]
K --> M[返回原始文本]
```

**Diagram sources**
- [draft.py](file://rdagent/scenarios/data_science/proposal/exp_gen/draft/draft.py#L134-L166)

## 依赖分析
提示模板系统依赖于多个核心组件和第三方库，形成了一个复杂的依赖网络。系统通过清晰的模块划分和接口定义，降低了组件间的耦合度。

```mermaid
graph TD
Prompts[prompts.py] --> YAML[yaml]
Prompts --> Path[Path]
Tpl[tpl.py] --> Jinja2[jinja2]
Tpl --> YAML
Tpl --> Inspect[inspect]
Tpl --> RD_AGENT_SETTINGS[RD_AGENT_SETTINGS]
Tpl --> logger[rdagent_logger]
Tpl --> Prompts : "使用"
Prompts --> Tpl : "被引用"
DataScienceConf[conf.py] --> SettingsConfigDict[SettingsConfigDict]
DataScienceConf --> KaggleBasePropSetting[KaggleBasePropSetting]
DataScienceConf --> DS_RD_SETTING[DS_RD_SETTING]
DataScienceConf --> Tpl : "使用T类"
DataScienceConf --> Prompts : "使用Prompts类"
PromptsV2[prompts_v2.yaml] --> Share[share.yaml]
PromptsV2 --> Scen[scen.prompts.yaml]
PromptsV2 --> ComponentSpec[component_spec.*]
PipelinePrompts[pipeline/prompts.yaml] --> Share
PipelinePrompts --> Spec[spec.*]
PipelinePrompts --> Guidelines[guidelines.*]
```

**Diagram sources**
- [prompts.py](file://rdagent/core/prompts.py#L0-L20)
- [tpl.py](file://rdagent/utils/agent/tpl.py#L0-L148)
- [conf.py](file://rdagent/app/data_science/conf.py#L0-L206)

**Section sources**
- [prompts.py](file://rdagent/core/prompts.py#L0-L20)
- [tpl.py](file://rdagent/utils/agent/tpl.py#L0-L148)
- [conf.py](file://rdagent/app/data_science/conf.py#L0-L206)

## 性能考虑
提示模板系统的性能主要受模板加载和渲染速度的影响。系统通过缓存机制和高效的文件I/O操作优化了性能表现。

1. **模板缓存**：系统通过`SingletonBaseClass`实现模板的单例模式，避免重复加载和解析相同的模板文件。
2. **文件I/O优化**：模板加载器优先尝试高优先级路径，减少不必要的文件系统访问。
3. **内存管理**：系统在加载YAML文件时使用流式解析，避免一次性加载大文件导致内存溢出。
4. **渲染效率**：Jinja2模板引擎经过优化，能够快速处理复杂的模板逻辑和大量变量注入。

## 故障排除指南
### 常见问题及解决方案
1. **模板文件找不到**
   - 检查文件路径是否正确，特别是相对路径和绝对路径的区别
   - 确认`RD_AGENT_SETTINGS.app_tpl`配置是否正确设置了应用模板路径
   - 验证文件扩展名是否匹配（.yaml或.txt）

2. **变量注入失败**
   - 检查上下文变量名称是否与模板中的变量名称完全匹配
   - 确认变量类型是否正确，特别是嵌套对象的属性访问
   - 验证Jinja2模板语法是否正确，特别是`{{ }}`和`{% %}`的使用

3. **条件逻辑不生效**
   - 检查条件表达式中的变量是否已正确定义
   - 确认布尔值的传递是否正确，特别是在YAML配置中
   - 验证Jinja2语法是否正确，特别是`{% if %}`、`{% else %}`和`{% endif %}`的配对

4. **模板继承失败**
   - 检查`{% include %}`语句中的URI格式是否正确
   - 确认被包含的模板文件是否存在且可访问
   - 验证模板路径是否在搜索路径列表中

**Section sources**
- [tpl.py](file://rdagent/utils/agent/tpl.py#L0-L148)
- [prompts.py](file://rdagent/core/prompts.py#L0-L20)

## 结论
提示模板管理系统通过分层的目录结构、灵活的模板继承机制和强大的变量注入功能，为复杂的AI应用提供了可靠的提示管理解决方案。系统采用YAML格式存储模板，结合Jinja2模板引擎实现动态内容生成，支持条件逻辑和模板包含等高级功能。通过单例模式和高效的文件I/O操作，系统在保证功能丰富性的同时也注重性能优化。该系统的设计模式可为其他类似的提示工程项目提供有价值的参考。